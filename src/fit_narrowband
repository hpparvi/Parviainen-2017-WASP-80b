#!/usr/bin/env python
from numpy import array, ones_like, concatenate, s_
from numpy.random import normal, uniform
from argparse import ArgumentParser
from os.path import exists

from core import *
from sampler import Sampler
#from lpf_narrowband_wn  import LPFC as LPFWN
#from lpf_narrowband_dw  import LPFC as LPFDW
#from lpf_dwt import LPFC as LPFDWTA
#from lpf_narrowband_gp  import LPFC as LPFRN

from lpf_singlerun import LPFC as LPFSR
from lpf_multirun  import LPFC as LPFMR

if __name__ == '__main__':
    ap = ArgumentParser()
    ap.add_argument('--use-ldtk', action='store_true', default=False)
    ap.add_argument('--passband', type=str, choices=['bb', 'nb', 'K', 'Na'])
    ap.add_argument('--nights', type=str, choices=['1', '2', '12'])
    ap.add_argument('--noise', choices=['white', 'red', 'dw', 'dwt', 'dwta'], default='white')
    ap.add_argument('--n-walkers',       type=int, default=600)
    ap.add_argument('--n-threads',       type=int, default=4)
    ap.add_argument('--night',           type=int, default=2)
    ap.add_argument('--do-de', action='store_true', default=False)
    ap.add_argument('--do-mc', action='store_true', default=False)
    ap.add_argument('--dont-continue-de', dest='continue_de', action='store_false', default=True)
    ap.add_argument('--dont-continue-mc', dest='continue_mc', action='store_false', default=True)
    ap.add_argument('--reset-chain', action='store_true', default=True)
    ap.add_argument('--de-n-iterations',    type=int, default=1000)
    ap.add_argument('--de-save-interval',   type=int, default= 100)
    ap.add_argument('--de-update-interval', type=int, default=  10)
    ap.add_argument('--mc-n-runs',          type=int, default=   1)
    ap.add_argument('--mc-n-iterations',    type=int, default=2000)
    ap.add_argument('--mc-thin'  ,          type=int, default=  50)
    ap.add_argument('--mc-save-interval',   type=int, default= 100)
    ap.add_argument('--mc-update-interval', type=int, default=  10)
    args = ap.parse_args()

    fname = 'gtc_{:s}_n{:s}{:s}'.format(args.passband, args.nights, '_ldtk' if args.use_ldtk else '')
    de_file = fname+'_de.npz'
    mc_file = fname+'_mc.npz'

    de_exists = exists(de_file)
    mc_exists = exists(mc_file)

    if args.nights in ['1','2']:
        lpf = LPFSR(use_ldtk=args.use_ldtk, n_threads=args.n_threads, night=args.night)
    else:
        lpf = LPFMR(use_ldtk=args.use_ldtk, n_threads=args.n_threads)
                
    # if args.noise == 'white':
    #     lpf = LPFWN(use_ldtk=args.use_ldtk, n_threads=args.n_threads)
    # elif args.noise == 'dw':
    #     lpf = 
    # elif args.noise == 'dwt':
    #     lpf = LPFDWT(use_ldtk=args.use_ldtk, n_threads=args.n_threads)
    # elif args.noise == 'red':
    #     lpf = LPFRN(use_ldtk=args.use_ldtk, n_threads=args.n_threads)
    # elif args.noise == 'dwta':
    #     lpf = LPFDWTA(use_ldtk=args.use_ldtk, n_threads=args.n_threads)

    sampler = Sampler(fname, rname, lpf, args.n_walkers, mc_thin=args.mc_thin,
                      mc_nruns=args.mc_n_runs, notebook=False,
                      de_iupdate=args.de_update_interval, de_isave=args.de_save_interval,
                      mc_iupdate=args.mc_update_interval, mc_isave=args.mc_save_interval)

    #if args.noise == 'red':
    #    sampler.de.C = 0.25
    
    sampler.info('Saving results to %s', relpath(fname))
    sampler.info('Run name %s', rname)
    sampler.info('Population size %i', args.n_walkers)
    
    ## Differential evolution
    ## ----------------------
    ## DE population can either start from a) scratch, b) previous run with same noise
    ## model, or c) white-noise run if running a red-noise model.
    ##
    if de_exists:
        pop = np.load(de_file)['population']
        sampler.info('Continuing DE from a previous run')
    elif args.noise == 'red' and exists(mc_file.replace('wn','rn')):
        pop = np.load(mc_file.replace('wn','rn'))['chains']
        pop = pop[:args.n_walkers, -1, :sampler.lpf.ps.ndim]
        pop[:,sampler.lpf._sbl:] = uniform(0.997,1.003,size=(args.n_walkers,2*sampler.lpf.npb))
        sampler.info('Continuing DE from a white noise run')
    else:
        pop = None
        sampler.info('Couldnt find DE results, forcing a DE run')
        
    if args.do_de or not de_exists:
        sampler.optimise(args.de_n_iterations, population=pop)

    ## MCMC sampling
    ## -------------
    if args.do_mc:
        sampler.info('Running MC with %i runs and %i iterations', args.mc_n_runs, args.mc_n_iterations)
        if args.continue_mc and mc_exists:
            p0 = np.load(mc_file)['chains'][:,-1,:]
        else:
            p0 = None
            
        sampler.sample(args.mc_n_iterations, population=p0)
 
