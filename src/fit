#!/usr/bin/env python
from numpy import array, ones_like, concatenate, s_
from numpy.random import normal, uniform
from argparse import ArgumentParser
from os.path import exists

from core import *
from sampler import Sampler

from lpf_singlerun import LPFC as LPFSR
from lpf_multirun  import LPFC as LPFMR
from lpf_multirun_direct import LPFC as LPFMD

if __name__ == '__main__':
    ap = ArgumentParser()
    ap.add_argument('--use-ldtk', action='store_true', default=False)
    ap.add_argument('--passband', type=str, choices=['w', 'bb', 'nb', 'K', 'Na'])
    ap.add_argument('--nights', type=int, choices=[1, 2, 12])
    ap.add_argument('--approach', type=str, choices=['dw','abs'], default='dw')
    ap.add_argument('--lc-type', type=str, choices=['target','relative'], default='target')
    ap.add_argument('--noise', type=str, choices=['white', 'red'])
    ap.add_argument('--mask-ingress', action='store_true', default=False)
    ap.add_argument('--n-walkers',       type=int, default=600)
    ap.add_argument('--n-threads',       type=int, default=4)
    ap.add_argument('--night',           type=int, default=2)
    ap.add_argument('--do-de', action='store_true', default=False)
    ap.add_argument('--do-mc', action='store_true', default=False)
    ap.add_argument('--dont-continue-de', dest='continue_de', action='store_false', default=True)
    ap.add_argument('--dont-continue-mc', dest='continue_mc', action='store_false', default=True)
    ap.add_argument('--reset-chain', action='store_true', default=True)
    ap.add_argument('--de-n-iterations',    type=int, default=1000)
    ap.add_argument('--de-save-interval',   type=int, default= 100)
    ap.add_argument('--de-update-interval', type=int, default=  10)
    ap.add_argument('--mc-n-runs',          type=int, default=   1)
    ap.add_argument('--mc-n-iterations',    type=int, default=2000)
    ap.add_argument('--mc-thin'  ,          type=int, default=  50)
    ap.add_argument('--mc-save-interval',   type=int, default= 100)
    ap.add_argument('--mc-update-interval', type=int, default=  10)
    args = ap.parse_args()

    if args.approach == 'dw':
        fname = 'gtc_{pb:s}_n{nights:s}_{lctype:s}_{noise:s}_{ldtk:s}{ingress:s}'.format(pb=args.passband, nights=str(args.nights),
                                                    lctype=args.lc_type, noise=args.noise,
                                                    ldtk='ldtk' if args.use_ldtk else 'noldtk',
                                                    ingress='_noingress' if args.mask_ingress else '')
    else:
        fname = 'xxx_{pb:s}_n{nights:s}_{lctype:s}_{noise:s}_{ldtk:s}{ingress:s}'.format(pb=args.passband, nights=str(args.nights),
                                                    lctype=args.lc_type, noise=args.noise,
                                                    ldtk='ldtk' if args.use_ldtk else 'noldtk',
                                                    ingress='_noingress' if args.mask_ingress else '')

    de_file = join(DRESULT, fname+'_de.npz')
    mc_file = join(DRESULT, fname+'_mc.npz')

    de_exists = exists(de_file)
    mc_exists = exists(mc_file)

    if args.approach == 'abs':
        lpf = LPFMD(args.passband, lctype=args.lc_type, use_ldtk=args.use_ldtk, noise=args.noise, n_threads=args.n_threads, mask_ingress=args.mask_ingress)
    else:
        if args.nights in [1,2]:
            lpf = LPFSR(args.passband, lctype=args.lc_type, use_ldtk=args.use_ldtk, noise=args.noise, n_threads=args.n_threads, night=args.nights, mask_ingress=args.mask_ingress)
        else:
            lpf = LPFMR(args.passband, lctype=args.lc_type, use_ldtk=args.use_ldtk, noise=args.noise, n_threads=args.n_threads, mask_ingress=args.mask_ingress)

    sampler = Sampler(join(DRESULT,fname), fname, lpf, args.n_walkers, mc_thin=args.mc_thin,
                      mc_nruns=args.mc_n_runs, notebook=False,
                      de_iupdate=args.de_update_interval, de_isave=args.de_save_interval,
                      mc_iupdate=args.mc_update_interval, mc_isave=args.mc_save_interval)

    sampler.info('Saving results to %s', relpath(fname))
    sampler.info('Run name %s', fname)
    sampler.info('Population size %i', args.n_walkers)
    
    ## Differential evolution
    ## ----------------------
    ## DE population can either start from a) scratch, b) previous run with same noise
    ## model, or c) white-noise run if running a red-noise model.
    ##
    if de_exists:
        pop = np.load(de_file)['population']
        sampler.info('Continuing DE from a previous run')
    else:
        pop = None
        sampler.info('Couldnt find DE results, forcing a DE run')
        
    if args.do_de or not de_exists:
        sampler.optimise(args.de_n_iterations, population=pop)

    ## MCMC sampling
    ## -------------
    if args.do_mc:
        sampler.info('Running MC with %i runs and %i iterations', args.mc_n_runs, args.mc_n_iterations)
        if args.continue_mc and mc_exists:
            p0 = np.load(mc_file)['chains'][:,-1,:]
        else:
            p0 = None
            
        sampler.sample(args.mc_n_iterations, population=p0)
 
